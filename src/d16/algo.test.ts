import {
  generatePattern,
  calculate,
  decodeSignal,
  calculateNoPattern
} from './algo';

test.each([
  [[0, 1, 0, -1], 0, 8, [1, 0, -1, 0, 1, 0, -1, 0]],
  [[0, 1, 0, -1], 1, 8, [0, 1, 1, 0, 0, -1, -1, 0]],
  [[0, 1, 0, -1], 2, 8, [0, 0, 1, 1, 1, 0, 0, 0]]
])(
  'generate pattern',
  (sequence: number[], position: number, length: number, pattern: number[]) => {
    expect(generatePattern(sequence, position, length)).toStrictEqual(pattern);
  }
);

test.each([
  [[1, 2, 3, 4, 5, 6, 7, 8], 4, [0, 1, 0, 2, 9, 4, 9, 8]],
  [
    [
      8,
      0,
      8,
      7,
      1,
      2,
      2,
      4,
      5,
      8,
      5,
      9,
      1,
      4,
      5,
      4,
      6,
      6,
      1,
      9,
      0,
      8,
      3,
      2,
      1,
      8,
      6,
      4,
      5,
      5,
      9,
      5
    ],
    100,
    [2, 4, 1, 7, 6, 1, 7, 6]
  ],
  [
    [
      1,
      9,
      6,
      1,
      7,
      8,
      0,
      4,
      2,
      0,
      7,
      2,
      0,
      2,
      2,
      0,
      9,
      1,
      4,
      4,
      9,
      1,
      6,
      0,
      4,
      4,
      1,
      8,
      9,
      9,
      1,
      7
    ],
    100,
    [7, 3, 7, 4, 5, 4, 1, 8]
  ],
  [
    [
      6,
      9,
      3,
      1,
      7,
      1,
      6,
      3,
      4,
      9,
      2,
      9,
      4,
      8,
      6,
      0,
      6,
      3,
      3,
      5,
      9,
      9,
      5,
      9,
      2,
      4,
      3,
      1,
      9,
      8,
      7,
      3
    ],
    100,
    [5, 2, 4, 3, 2, 1, 3, 3]
  ]
])('calculate', (input: number[], phases: number, res: number[]) => {
  expect(calculate(input, phases).slice(0, 8)).toStrictEqual(res);
});

test.each([
  [[1, 2, 3, 4, 5, 6, 7, 8], 4, [0, 1, 0, 2, 9, 4, 9, 8]],
  [
    [
      8,
      0,
      8,
      7,
      1,
      2,
      2,
      4,
      5,
      8,
      5,
      9,
      1,
      4,
      5,
      4,
      6,
      6,
      1,
      9,
      0,
      8,
      3,
      2,
      1,
      8,
      6,
      4,
      5,
      5,
      9,
      5
    ],
    100,
    [2, 4, 1, 7, 6, 1, 7, 6]
  ],
  [
    [
      1,
      9,
      6,
      1,
      7,
      8,
      0,
      4,
      2,
      0,
      7,
      2,
      0,
      2,
      2,
      0,
      9,
      1,
      4,
      4,
      9,
      1,
      6,
      0,
      4,
      4,
      1,
      8,
      9,
      9,
      1,
      7
    ],
    100,
    [7, 3, 7, 4, 5, 4, 1, 8]
  ],
  [
    [
      6,
      9,
      3,
      1,
      7,
      1,
      6,
      3,
      4,
      9,
      2,
      9,
      4,
      8,
      6,
      0,
      6,
      3,
      3,
      5,
      9,
      9,
      5,
      9,
      2,
      4,
      3,
      1,
      9,
      8,
      7,
      3
    ],
    100,
    [5, 2, 4, 3, 2, 1, 3, 3]
  ]
])('calculate', (input: number[], phases: number, res: number[]) => {
  expect(calculateNoPattern(input, phases).slice(0, 8)).toStrictEqual(res);
});

test.each([
  [
    [
      0,
      3,
      0,
      3,
      6,
      7,
      3,
      2,
      5,
      7,
      7,
      2,
      1,
      2,
      9,
      4,
      4,
      0,
      6,
      3,
      4,
      9,
      1,
      5,
      6,
      5,
      4,
      7,
      4,
      6,
      6,
      4
    ],
    [8, 4, 4, 6, 2, 0, 2, 6]
  ],
  [
    [
      0,
      2,
      9,
      3,
      5,
      1,
      0,
      9,
      6,
      9,
      9,
      9,
      4,
      0,
      8,
      0,
      7,
      4,
      0,
      7,
      5,
      8,
      5,
      4,
      4,
      7,
      0,
      3,
      4,
      3,
      2,
      3
    ],
    [7, 8, 7, 2, 5, 2, 7, 0]
  ],
  [
    [
      0,
      3,
      0,
      8,
      1,
      7,
      7,
      0,
      8,
      8,
      4,
      9,
      2,
      1,
      9,
      5,
      9,
      7,
      3,
      1,
      1,
      6,
      5,
      4,
      4,
      6,
      8,
      5,
      0,
      5,
      1,
      7
    ],
    [5, 3, 5, 5, 3, 7, 3, 1]
  ]
])('decode signal', (input: number[], output: number[]) => {
  expect(decodeSignal(input)).toStrictEqual(output);
});
